# 选股频道实现设计文档

## 1. 需求概述

### 1.1 功能需求
在前端网站中新增一个"选股"频道，位于"行情"频道后面，实现创业板中线选股策略功能。

### 1.2 业务需求
- **股票范围**：创业板股票（代码以3开头）
- **时间范围**：最近3-4个月的历史数据（从当前日期往前推）
- **选股策略**：基于技术分析的多个条件组合，筛选出符合特定技术形态的股票

### 1.3 用户需求
- 用户可以通过选股频道查看符合特定技术策略的股票列表
- 列表显示关键信息：代码、名称、涨停日期、突破日期、当前行情信息等
- 提供快捷链接跳转到历史行情页和股票详情页

## 2. 选股策略详细说明

### 2.1 策略条件（按时间顺序）

#### 条件1：起始一个涨停
- **定义**：今天涨停前3-4个月都没有过涨停（即该涨停往前推3-4个月内没有其他涨停）
- **判断标准**：涨幅 >= 9.8%（创业板涨跌幅限制为20%）
- **判断逻辑**：
  - 从最新数据往前查找涨停
  - 找到涨停后，检查该涨停往前推3-4个月（约120个交易日）内是否有其他涨停
  - 如果往前3-4个月内没有涨停，则符合条件
  - 如果往前有涨停，继续往后查找下一个涨停
- **记录信息**：
  - 涨停日期
  - 涨停价格（收盘价）
  - 涨停底部（最低价）
  - 涨停高点（最高价）

#### 条件2：第一次回调不跌穿涨停底部
- **定义**：涨停后出现回调，但最低价不低于涨停当天的最低价
- **判断逻辑**：
  - 从涨停日期往后的交易日中查找
  - 如果出现回调（收盘价低于涨停价）
  - 但最低价仍不低于涨停当天的low
  - 如果中途跌破涨停底部，则不符合条件

#### 条件3：第二次上涨突破第一个涨停高点
- **定义**：回调后再次上涨，突破涨停当天的最高价
- **判断标准**：最高价 > 涨停当天的high

#### 条件4：跳空揉搓指标
- **向上跳空**：当日最低价 > 前一日最高价
- **揉搓线**：
  - 实体小：|收盘价 - 开盘价| / 前收盘价 < 2%
  - 上影线长：(最高价 - max(开盘价,收盘价)) / 前收盘价 > 1%
  - 下影线长：(min(开盘价,收盘价) - 最低价) / 前收盘价 > 1%
- **要求**：在涨停和突破之间，至少有一个向上跳空和一个揉搓线

#### 条件5：均线多头排列
- **定义**：当前满足 MA5 > MA10 > MA20
- **说明**：只要满足MA5 > MA10 > MA20即可，不一定要求所有均线都向上发散
- **均线计算**：
  - MA5：最近5个交易日的收盘价平均值
  - MA10：最近10个交易日的收盘价平均值
  - MA20：最近20个交易日的收盘价平均值

### 2.2 策略流程图

```
开始
  ↓
获取创业板股票列表（代码以3开头）
  ↓
对每只股票执行以下检查：
  ↓
[条件1] 查找第一个涨停（涨幅>=9.8%）
  ├─ 未找到 → 跳过该股票
  └─ 找到 → 检查该涨停往前3-4个月是否有其他涨停
      ├─ 往前有涨停 → 继续查找下一个涨停
      └─ 往前无涨停 → 记录涨停信息
      ↓
[条件2] 检查回调不破底
  ├─ 跌破 → 跳过该股票
  └─ 不破 → 继续
      ↓
[条件3] 检查突破涨停高点
  ├─ 未突破 → 跳过该股票
  └─ 突破 → 继续
      ↓
[条件4] 检查跳空和揉搓线
  ├─ 不满足 → 跳过该股票
  └─ 满足 → 继续
      ↓
[条件5] 检查均线多头排列
  ├─ 不满足 → 跳过该股票
  └─ 满足 → 加入结果列表
      ↓
返回符合条件的股票列表
```

## 3. 技术方案设计

### 3.1 系统架构

```
前端 (Frontend)
  ├─ screening.html          # 选股页面
  ├─ css/screening.css       # 样式文件
  └─ js/screening.js         # 业务逻辑
      ↓
  API调用 (HTTP)
      ↓
后端 (Backend)
  ├─ stock_screening_routes.py    # API路由
  └─ stock_screening.py          # 选股策略算法
      ↓
数据库查询 (PostgreSQL/SQLite)
  ├─ stock_basic_info          # 股票基本信息
  └─ historical_quotes        # 历史行情数据
```

### 3.2 数据流设计

```
用户点击"刷新筛选"
  ↓
前端发送API请求: GET /api/screening/cyb-midline-strategy?months=4
  ↓
后端接收请求，调用选股策略函数
  ↓
查询数据库获取创业板股票列表
  ↓
对每只股票：
  1. 查询最近3-4个月历史数据（按日期倒序）
  2. 执行策略条件检查
  3. 如果全部满足，加入结果列表
  ↓
返回JSON格式结果
  ↓
前端接收结果，渲染表格
```

### 3.3 核心算法设计

#### 3.3.1 数据预处理
- 历史数据按日期倒序排列（最新在前）
- 索引0对应最新日期，索引越大对应越早的日期
- 确保日期格式统一为字符串 'YYYY-MM-DD'
- **重要**：数据库中的 `date` 字段是 `text` 类型，查询时需要使用字符串格式的日期参数

#### 3.3.2 涨停查找算法

**方法签名：**
```python
@staticmethod
def find_first_limit_up(historical_data: List[Dict], months_before: int = 4) -> Optional[Dict]
```

**算法逻辑：**
```python
def find_first_limit_up(historical_data, months_before=4):
    """
    查找第一个涨停（今天涨停前3-4个月都没有过涨停）
    数据倒序排列，从最新往前查找
    """
    days_to_check = months_before * 30
    
    for i, data in enumerate(historical_data):
        if data.change_percent >= 9.8:
            # 找到涨停后，检查往前3-4个月是否有其他涨停
            limit_up_index = i
            has_previous_limit_up = False
            
            # 往前检查足够的天数（约120个交易日）
            check_end_index = min(limit_up_index + days_to_check, len(historical_data))
            
            for j in range(limit_up_index + 1, check_end_index):
                prev_data = historical_data[j]
                if prev_data.change_percent >= 9.8:
                    has_previous_limit_up = True
                    break
            
            # 如果往前3-4个月内没有涨停，则符合条件
            if not has_previous_limit_up:
                return {
                    'date': data.date,
                    'index': i,
                    'close': data.close,
                    'low': data.low,
                    'high': data.high
                }
            # 如果往前有涨停，继续往后查找下一个涨停
    
    return None
```

#### 3.3.3 回调检查算法

**方法签名：**
```python
@staticmethod
def check_pullback_not_break_bottom(historical_data: List[Dict], limit_up_info: Dict) -> Tuple[bool, Optional[Dict]]
```

**算法逻辑：**
```python
def check_pullback_not_break_bottom(historical_data, limit_up_info):
    """
    检查回调不破底
    从涨停索引往前（更新日期）查找回调
    """
    limit_up_index = limit_up_info['index']
    limit_up_low = limit_up_info['low']
    
    for i in range(limit_up_index - 1, -1, -1):
        current_low = historical_data[i]['low']
        current_close = historical_data[i]['close']
        
        # 如果跌破涨停底部，不符合条件
        if current_low < limit_up_low:
            return False, None
        
        # 如果出现回调（收盘价低于涨停价）
        if current_close < limit_up_info['close']:
            return True, pullback_info
    
    return False, None
```

#### 3.3.4 突破检查算法

**方法签名：**
```python
@staticmethod
def check_breakthrough(historical_data: List[Dict], limit_up_info: Dict) -> Tuple[bool, Optional[Dict]]
```

**算法逻辑：**
```python
def check_breakthrough(historical_data, limit_up_info):
    """
    检查突破涨停高点
    从涨停索引往前查找突破
    """
    limit_up_high = limit_up_info['high']
    
    for i in range(limit_up_index - 1, -1, -1):
        current_high = historical_data[i]['high']
        
        if current_high > limit_up_high:
            return True, breakthrough_info
    
    return False, None
```

#### 3.3.5 跳空和揉搓线检查算法

**方法签名：**
```python
@staticmethod
def check_gap_and_doji(historical_data: List[Dict], limit_up_index: int, breakthrough_index: int) -> Tuple[bool, List[str], List[str]]
```

**算法逻辑：**
```python
def check_gap_and_doji(historical_data, limit_up_index, breakthrough_index):
    """
    检查涨停和突破之间的跳空和揉搓线
    注意：数据倒序，索引i对应较新日期，i+1对应较旧日期（前一日）
    """
    start_idx = breakthrough_index + 1  # 突破后的第一个交易日
    end_idx = limit_up_index - 1        # 涨停前的最后一个交易日
    
    gap_dates = []
    doji_dates = []
    
    for i in range(start_idx, end_idx + 1):
        current_data = historical_data[i]
        prev_data = historical_data[i + 1]  # 前一日（时间上更早）
        
        # 检查向上跳空
        if current_data['low'] > prev_data['high']:
            gap_dates.append(current_data['date'])
        
        # 检查揉搓线
        body_size = abs(current_data['close'] - current_data['open']) / prev_data['close']
        upper_shadow = (current_data['high'] - max(current_data['open'], current_data['close'])) / prev_data['close']
        lower_shadow = (min(current_data['open'], current_data['close']) - current_data['low']) / prev_data['close']
        
        if body_size < 0.02 and upper_shadow > 0.01 and lower_shadow > 0.01:
            doji_dates.append(current_data['date'])
    
    return len(gap_dates) > 0 and len(doji_dates) > 0, gap_dates, doji_dates
```

#### 3.3.6 均线多头排列检查算法

**方法签名：**
```python
@staticmethod
def check_ma_alignment(historical_data: List[Dict], current_index: int = 0) -> Tuple[bool, Dict]
```

**算法逻辑：**
```python
def check_ma_alignment(historical_data, current_index=0):
    """
    检查均线多头排列（MA5 > MA10 > MA20）
    注意：只要满足MA5 > MA10 > MA20即可，不一定要求所有均线都向上发散
    数据倒序，从当前索引往前取20个交易日
    """
    closes = []
    for i in range(current_index, min(current_index + 20, len(historical_data))):
        closes.append(historical_data[i]['close'])
    
    ma5 = mean(closes[:5])
    ma10 = mean(closes[:10])
    ma20 = mean(closes[:20])
    
    # 检查多头排列：MA5 > MA10 > MA20
    # 只要满足这个条件即可，不要求所有均线都向上发散
    return ma5 > ma10 > ma20, {'ma5': ma5, 'ma10': ma10, 'ma20': ma20}
```

## 4. 接口设计

### 4.1 API接口

**接口路径：** `GET /api/screening/cyb-midline-strategy`

**请求参数：**
| 参数名 | 类型 | 必填 | 默认值 | 说明 |
|--------|------|------|--------|------|
| months | int | 否 | 4 | 查询月数（3-4个月） |

**请求示例：**
```http
GET /api/screening/cyb-midline-strategy?months=4
Authorization: Bearer {token}
```

**响应格式：**
```json
{
  "success": true,
  "data": [
    {
      "code": "300300",
      "name": "海峡创新",
      "limit_up_date": "2025-01-15",
      "limit_up_price": 12.50,
      "limit_up_low": 11.80,
      "limit_up_high": 12.50,
      "breakthrough_date": "2025-01-25",
      "breakthrough_price": 12.80,
      "current_price": 12.94,
      "current_change_percent": 19.70,
      "ma5": 12.10,
      "ma10": 11.80,
      "ma20": 11.50,
      "gap_dates": ["2025-01-18", "2025-01-20"],
      "doji_dates": ["2025-01-19"]
    }
  ],
  "total": 10,
  "search_date": "2025-01-20",
  "months": 4,
  "strategy_name": "创业板中线选股策略"
}
```

**错误响应：**
```json
{
  "detail": "选股策略执行失败: {错误信息}"
}
```

### 4.2 数据字段说明

| 字段名 | 类型 | 说明 |
|--------|------|------|
| code | string | 股票代码（6位数字） |
| name | string | 股票名称 |
| limit_up_date | string | 涨停日期（YYYY-MM-DD） |
| limit_up_price | float | 涨停价格（收盘价） |
| limit_up_low | float | 涨停最低价 |
| limit_up_high | float | 涨停最高价 |
| breakthrough_date | string | 突破日期（YYYY-MM-DD） |
| breakthrough_price | float | 突破价格（收盘价） |
| current_price | float | 当前价格 |
| current_change_percent | float | 当前涨跌幅（%） |
| ma5 | float | MA5均线值 |
| ma10 | float | MA10均线值 |
| ma20 | float | MA20均线值 |
| gap_dates | array | 向上跳空日期列表 |
| doji_dates | array | 揉搓线日期列表 |

## 5. 前端实现设计

### 5.1 页面结构

```
screening.html
├── header-container (动态加载)
├── screening-container
    ├── screening-header (标题和描述)
    ├── strategy-info-card (策略说明卡片)
    ├── screening-actions (操作按钮和日期)
    ├── loading-indicator (加载状态)
    ├── error-message (错误提示)
    └── results-container
        ├── results-header (结果计数)
        └── results-table-wrapper
            └── results-table (股票列表表格)
```

### 5.2 页面功能

1. **策略说明展示**
   - 显示策略的详细条件和说明
   - 帮助用户理解选股逻辑

2. **刷新筛选**
   - 点击"刷新筛选"按钮触发选股
   - 显示加载状态
   - 显示筛选时间

3. **结果列表展示**
   - 表格形式展示符合条件的股票
   - 显示关键信息字段
   - 提供历史、详情链接

4. **错误处理**
   - 显示API调用错误信息
   - 友好的错误提示

### 5.3 交互流程

```
页面加载
  ↓
加载header组件
  ↓
初始化用户菜单和搜索功能
  ↓
页面自动执行一次筛选
  ↓
用户点击"刷新筛选"
  ↓
显示加载状态
  ↓
调用API获取选股结果
  ↓
隐藏加载状态
  ↓
渲染结果列表
  ↓
用户点击"历史"或"详情"链接
  ↓
跳转到对应页面
```

## 6. 数据库设计

### 6.1 涉及的表

**stock_basic_info**
- 用途：获取创业板股票列表
- 查询条件：`code LIKE '3%' AND LENGTH(code) = 6`

**historical_quotes**
- 用途：获取股票历史行情数据
- 查询条件：
  - `code = :code`
  - `date >= :start_date AND date <= :end_date`（注意：date字段是text类型）
  - `ORDER BY date DESC`
- **重要说明**：数据库中的 `date` 字段是 `text` 类型，查询时必须使用字符串格式的日期参数（'YYYY-MM-DD'）

### 6.2 查询优化建议

1. **索引优化**
   - `stock_basic_info.code` 需要索引
   - `historical_quotes(code, date)` 需要复合索引

2. **批量查询**
   - 避免逐个股票查询，考虑批量获取

3. **数据缓存**
   - 股票基本信息可以缓存
   - 历史数据可以考虑分页或限制查询范围

## 7. 文件清单

### 7.1 后端文件

| 文件路径 | 说明 |
|---------|------|
| `backend_api/stock/stock_screening.py` | 选股策略核心算法 |
| `backend_api/stock/stock_screening_routes.py` | API路由定义 |
| `backend_api/main.py` | 注册选股路由 |

### 7.2 前端文件

| 文件路径 | 说明 |
|---------|------|
| `frontend/screening.html` | 选股页面HTML |
| `frontend/css/screening.css` | 选股页面样式 |
| `frontend/js/screening.js` | 选股页面逻辑 |
| `frontend/components/header.html` | 添加选股导航链接 |

## 8. 错误处理

### 8.1 后端错误处理

#### 8.1.1 数据库事务错误处理

**问题：** PostgreSQL 中，当一次查询失败时，整个事务会被标记为失败状态，后续查询会被忽略。

**解决方案：** 在每个股票处理的异常处理中添加 `db.rollback()`，重置失败的事务状态。

```python
except Exception as e:
    logger.error(f"处理股票 {code} 时出错: {str(e)}")
    # 回滚事务以重置失败状态，避免影响后续查询
    try:
        db.rollback()
    except Exception as rollback_error:
        logger.warning(f"回滚事务时出错: {str(rollback_error)}")
    continue
```

#### 8.1.2 日期类型错误处理

**问题：** 数据库中的 `date` 字段是 `text` 类型，不能直接与 `date` 类型比较。

**解决方案：** 将日期参数转换为字符串格式（'YYYY-MM-DD'）后再进行字符串比较。

```python
# 转换为字符串格式（数据库中的date字段是text类型）
start_date_str = start_date.strftime('%Y-%m-%d')
end_date_str = end_date.strftime('%Y-%m-%d')

# 在SQL查询中使用字符串格式的日期参数
history_query = db.execute(text("""
    SELECT ...
    WHERE date >= :start_date AND date <= :end_date
"""), {
    'start_date': start_date_str,
    'end_date': end_date_str
})
```

#### 8.1.3 其他错误处理

1. **数据库查询错误**
   - 记录日志
   - 跳过错误股票，继续处理其他股票
   - 使用事务回滚确保后续查询正常

2. **数据不足错误**
   - 如果历史数据不足20个交易日，跳过该股票
   - 记录警告日志

3. **计算错误**
   - 捕获异常
   - 记录详细错误信息
   - 返回部分结果（如果已处理部分股票）

### 8.2 前端错误处理

1. **API调用失败**
   - 显示错误提示
   - 允许用户重试

2. **数据解析错误**
   - 显示友好错误信息
   - 记录错误日志

## 9. 性能考虑

### 9.1 性能优化

1. **数据库查询优化**
   - 使用索引加速查询
   - 限制查询日期范围
   - 使用字符串格式的日期参数（避免类型转换开销）

2. **算法优化**
   - 早期退出：不满足条件立即跳过
   - 减少不必要的计算
   - 使用事务回滚避免阻塞

3. **前端优化**
   - 分页显示（如果结果太多）
   - 异步加载，不阻塞UI
   - 显示处理进度

### 9.2 性能指标

- **API响应时间**：目标 < 30秒（取决于股票数量）
- **前端渲染时间**：目标 < 1秒
- **数据库查询时间**：单只股票查询 < 100ms

## 10. 测试建议

### 10.1 单元测试

1. **选股策略算法测试**
   - 测试涨停查找逻辑
   - 测试回调检查逻辑
   - 测试突破检查逻辑
   - 测试跳空和揉搓线检查
   - 测试均线多头排列检查

2. **边界条件测试**
   - 数据不足的情况
   - 没有涨停的情况
   - 涨停后立即突破的情况
   - 没有回调的情况

3. **错误处理测试**
   - 数据库事务错误处理
   - 日期类型错误处理
   - 数据格式错误处理

### 10.2 集成测试

1. **API接口测试**
   - 测试正常请求
   - 测试参数验证
   - 测试错误处理

2. **端到端测试**
   - 测试完整选股流程
   - 测试前端展示
   - 测试链接跳转

## 11. 后续优化建议

### 11.1 功能扩展

1. **多策略支持**
   - 支持多个选股策略
   - 用户可以选择不同策略

2. **筛选条件调整**
   - 支持自定义时间范围
   - 支持调整策略参数

3. **结果排序**
   - 支持按不同字段排序
   - 支持筛选和搜索

### 11.2 性能优化

1. **缓存机制**
   - 缓存选股结果
   - 定时刷新缓存

2. **异步处理**
   - 后台异步执行选股
   - 用户可查看进度

3. **结果导出**
   - 支持导出Excel
   - 支持导出CSV

## 12. 版本历史

| 版本 | 日期 | 说明 |
|------|------|------|
| 1.0 | 2025-01-20 | 初始版本，实现创业板中线选股策略 |
| 1.1 | 2025-01-20 | 更新需求：第一个涨停的定义改为"今天涨停前3-4个月都没有过涨停"；均线多头排列明确为只需满足MA5>MA10>MA20 |
| 1.2 | 2025-11-05 | 修复数据库事务错误处理；修复日期类型比较问题 |

## 13. 附录

### 13.1 术语表

- **涨停**：股票价格上涨达到当日涨跌幅限制的上限
- **回调**：价格上涨后出现下跌
- **突破**：价格突破前期高点
- **向上跳空**：当日最低价高于前一日最高价
- **揉搓线**：K线形态，实体小，上下影线长
- **均线多头排列**：短期均线在长期均线之上（MA5 > MA10 > MA20），不一定要求所有均线都向上发散
- **事务回滚**：当数据库操作失败时，撤销已执行的操作，恢复到操作前的状态

### 13.2 技术要点

1. **数据库事务管理**
   - PostgreSQL 中，查询失败会导致整个事务失败
   - 需要在异常处理中显式回滚事务
   - 使用 `db.rollback()` 重置事务状态

2. **日期类型处理**
   - 数据库中的 `date` 字段可能是 `text` 类型
   - 查询时需要使用字符串格式的日期参数
   - 字符串格式 'YYYY-MM-DD' 可以直接进行字典序比较

3. **数据排序**
   - 历史数据按日期倒序排列（最新在前）
   - 索引0对应最新日期，索引越大对应越早的日期
   - 在比较前后日期时需要注意索引的方向

### 13.3 参考资料

- 股票技术分析相关书籍
- K线形态识别方法
- 均线系统分析理论
- PostgreSQL 事务管理文档
- SQLAlchemy 数据库操作文档
